// ⚠️ GENERATED CODE ⚠️ - this entire file was generated by the `roc glue` CLI command

#![allow(unused_unsafe)]
#![allow(dead_code)]
#![allow(unused_mut)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(non_upper_case_globals)]
#![allow(clippy::undocumented_unsafe_blocks)]
#![allow(clippy::redundant_static_lifetimes)]
#![allow(clippy::unused_unit)]
#![allow(clippy::missing_safety_doc)]
#![allow(clippy::let_and_return)]
#![allow(clippy::missing_safety_doc)]
#![allow(clippy::needless_borrow)]
#![allow(clippy::clone_on_copy)]
#![allow(clippy::non_canonical_partial_ord_impl)]


#[derive(Clone, Copy, Default, Debug, PartialEq, PartialOrd, )]
#[repr(C)]
pub struct Rgba {
    pub a: f32,
    pub b: f32,
    pub g: f32,
    pub r: f32,
}

#[derive(Clone, Copy, Default, Debug, PartialEq, PartialOrd, )]
#[repr(C)]
pub struct ButtonStyles {
    pub bgColor: Rgba,
    pub borderColor: Rgba,
    pub borderWidth: f32,
    pub textColor: Rgba,
}

#[derive(Clone, Debug, PartialEq, PartialOrd, )]
#[repr(C)]
pub struct Elem_Button {
    pub f0: Elem,
    pub f1: ButtonStyles,
}

#[derive(Clone, Debug, PartialEq, PartialOrd, )]
#[repr(transparent)]
pub struct Elem_Col {
    pub f0: roc_std::RocList<Elem>,
}

#[derive(Clone, Default, Debug, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(transparent)]
pub struct Elem_Text {
    pub f0: roc_std::RocStr,
}

#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(u8)]
pub enum discriminant_Elem {
    Button = 0,
    Col = 1,
    Row = 2,
    Text = 3,
}

impl core::fmt::Debug for discriminant_Elem {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Button => f.write_str("discriminant_Elem::Button"),
            Self::Col => f.write_str("discriminant_Elem::Col"),
            Self::Row => f.write_str("discriminant_Elem::Row"),
            Self::Text => f.write_str("discriminant_Elem::Text"),
        }
    }
}

#[repr(transparent)]
pub struct Elem(*mut union_Elem);

const _SIZE_CHECK_Elem: () = assert!(core::mem::size_of::<Elem>() == 8);
const _ALIGN_CHECK_Elem: () = assert!(core::mem::align_of::<Elem>() == 8);

impl Elem {
    pub fn discriminant(&self) -> discriminant_Elem {
        let discriminants = {
            use discriminant_Elem::*;

            [ Button, Col, Row, Text ]
        };

        if self.0.is_null() {
            unreachable!("this pointer cannot be NULL")
        } else  {
            match std::mem::size_of::<usize>() {
                4 => discriminants[self.0 as usize & 0b011],
                8 => discriminants[self.0 as usize & 0b111],
                _ => unreachable!(),
            }
        }
    }

    fn unmasked_pointer(&self) -> *mut union_Elem {
        debug_assert!(!self.0.is_null());

        let mask = match std::mem::size_of::<usize>() {
            4 => !0b011usize,
            8 => !0b111usize,
            _ => unreachable!(),
        };

        ((self.0 as usize) & mask) as *mut union_Elem
    }

    unsafe fn ptr_read_union(&self) -> core::mem::ManuallyDrop<union_Elem> {
        let ptr = self.unmasked_pointer();

        core::mem::ManuallyDrop::new(unsafe { std::ptr::read(ptr) })
    }

        pub fn is_Button(&self) -> bool {
        matches!(self.discriminant(), discriminant_Elem::Button)
    }

    pub fn Button(f0: Elem, f1: ButtonStyles) -> Self {
        let tag_id = discriminant_Elem::Button;

        let payload = Elem_Button { f0, f1 } ;

        let union_payload = union_Elem { Button: core::mem::ManuallyDrop::new(payload) };

        let ptr = unsafe { roc_std::RocBox::leak(roc_std::RocBox::new(union_payload)) };

        Self((ptr as usize | tag_id as usize) as *mut _)
    }

    pub fn get_Button_f0(&self) -> &Elem {
        debug_assert!(self.is_Button());

        // extern "C" {
        //     fn foobar(tag_id: u16, field_index: usize) -> usize;
        // }

        // let offset = unsafe { foobar(0) };
        let offset = 0;
        unsafe { &*self.unmasked_pointer().add(offset).cast() }
    }

    pub fn get_Button_f1(&self) -> &ButtonStyles {
        debug_assert!(self.is_Button());

        // extern "C" {
        //     fn foobar(tag_id: u16, field_index: usize) -> usize;
        // }

        // let offset = unsafe { foobar(1) };
        let offset = 0;
        unsafe { &*self.unmasked_pointer().add(offset).cast() }
    }


    pub fn get_Button(mut self) -> Elem_Button {
        debug_assert!(self.is_Button());

        unsafe { core::mem::ManuallyDrop::take(&mut self.ptr_read_union().Button) }
    }

    pub fn is_Col(&self) -> bool {
        matches!(self.discriminant(), discriminant_Elem::Col)
    }

    pub fn Col(f0: roc_std::RocList<Elem>) -> Self {
        let tag_id = discriminant_Elem::Col;

        let payload = Elem_Col { f0 } ;

        let union_payload = union_Elem { Col: core::mem::ManuallyDrop::new(payload) };

        let ptr = unsafe { roc_std::RocBox::leak(roc_std::RocBox::new(union_payload)) };

        Self((ptr as usize | tag_id as usize) as *mut _)
    }

    pub fn get_Col_f0(&self) -> &roc_std::RocList<Elem> {
        debug_assert!(self.is_Col());

        // extern "C" {
        //     fn foobar(tag_id: u16, field_index: usize) -> usize;
        // }

        // let offset = unsafe { foobar(0) };
        let offset = 0;
        unsafe { &*self.unmasked_pointer().add(offset).cast() }
    }


    pub fn get_Col(mut self) -> Elem_Col {
        debug_assert!(self.is_Col());

        unsafe { core::mem::ManuallyDrop::take(&mut self.ptr_read_union().Col) }
    }

    pub fn is_Row(&self) -> bool {
        matches!(self.discriminant(), discriminant_Elem::Row)
    }

    pub fn Row(f0: roc_std::RocList<Elem>) -> Self {
        let tag_id = discriminant_Elem::Row;

        let payload = Elem_Row { f0 } ;

        let union_payload = union_Elem { Row: core::mem::ManuallyDrop::new(payload) };

        let ptr = unsafe { roc_std::RocBox::leak(roc_std::RocBox::new(union_payload)) };

        Self((ptr as usize | tag_id as usize) as *mut _)
    }

    pub fn get_Row_f0(&self) -> &roc_std::RocList<Elem> {
        debug_assert!(self.is_Row());

        // extern "C" {
        //     fn foobar(tag_id: u16, field_index: usize) -> usize;
        // }

        // let offset = unsafe { foobar(0) };
        let offset = 0;
        unsafe { &*self.unmasked_pointer().add(offset).cast() }
    }


    pub fn get_Row(mut self) -> Elem_Row {
        debug_assert!(self.is_Row());

        unsafe { core::mem::ManuallyDrop::take(&mut self.ptr_read_union().Row) }
    }

    pub fn is_Text(&self) -> bool {
        matches!(self.discriminant(), discriminant_Elem::Text)
    }

    pub fn Text(f0: roc_std::RocStr) -> Self {
        let tag_id = discriminant_Elem::Text;

        let payload = Elem_Text { f0 } ;

        let union_payload = union_Elem { Text: core::mem::ManuallyDrop::new(payload) };

        let ptr = unsafe { roc_std::RocBox::leak(roc_std::RocBox::new(union_payload)) };

        Self((ptr as usize | tag_id as usize) as *mut _)
    }

    pub fn get_Text_f0(&self) -> &roc_std::RocStr {
        debug_assert!(self.is_Text());

        // extern "C" {
        //     fn foobar(tag_id: u16, field_index: usize) -> usize;
        // }

        // let offset = unsafe { foobar(0) };
        let offset = 0;
        unsafe { &*self.unmasked_pointer().add(offset).cast() }
    }


    pub fn get_Text(mut self) -> Elem_Text {
        debug_assert!(self.is_Text());

        unsafe { core::mem::ManuallyDrop::take(&mut self.ptr_read_union().Text) }
    }
}

impl Clone for Elem {
    fn clone(&self) -> Self {
        use discriminant_Elem::*;

        let discriminant = self.discriminant();

        match discriminant {
                    Button => {
                let tag_id = discriminant_Elem::Button;

                let payload_union = unsafe { self.ptr_read_union() };
                let payload = union_Elem {
                    Button: unsafe { payload_union.Button.clone() },
                };

                let ptr = unsafe { roc_std::RocBox::leak(roc_std::RocBox::new(payload)) };

                Self((ptr as usize | tag_id as usize) as *mut _)
            },
            Col => {
                let tag_id = discriminant_Elem::Col;

                let payload_union = unsafe { self.ptr_read_union() };
                let payload = union_Elem {
                    Col: unsafe { payload_union.Col.clone() },
                };

                let ptr = unsafe { roc_std::RocBox::leak(roc_std::RocBox::new(payload)) };

                Self((ptr as usize | tag_id as usize) as *mut _)
            },
            Row => {
                let tag_id = discriminant_Elem::Row;

                let payload_union = unsafe { self.ptr_read_union() };
                let payload = union_Elem {
                    Row: unsafe { payload_union.Row.clone() },
                };

                let ptr = unsafe { roc_std::RocBox::leak(roc_std::RocBox::new(payload)) };

                Self((ptr as usize | tag_id as usize) as *mut _)
            },
            Text => {
                let tag_id = discriminant_Elem::Text;

                let payload_union = unsafe { self.ptr_read_union() };
                let payload = union_Elem {
                    Text: unsafe { payload_union.Text.clone() },
                };

                let ptr = unsafe { roc_std::RocBox::leak(roc_std::RocBox::new(payload)) };

                Self((ptr as usize | tag_id as usize) as *mut _)
            },
        }
    }
}

impl PartialEq for Elem {
    fn eq(&self, other: &Self) -> bool {
        use discriminant_Elem::*;

        if self.discriminant() != other.discriminant() {
            return false;
        }

        match self.discriminant() {
                        Button => {
                let payload_union1 = unsafe { self.ptr_read_union() };
                let payload_union2 = unsafe { other.ptr_read_union() };

                unsafe {
                    payload_union1.Button == payload_union2.Button
                }
            },
            Col => {
                let payload_union1 = unsafe { self.ptr_read_union() };
                let payload_union2 = unsafe { other.ptr_read_union() };

                unsafe {
                    payload_union1.Col == payload_union2.Col
                }
            },
            Row => {
                let payload_union1 = unsafe { self.ptr_read_union() };
                let payload_union2 = unsafe { other.ptr_read_union() };

                unsafe {
                    payload_union1.Row == payload_union2.Row
                }
            },
            Text => {
                let payload_union1 = unsafe { self.ptr_read_union() };
                let payload_union2 = unsafe { other.ptr_read_union() };

                unsafe {
                    payload_union1.Text == payload_union2.Text
                }
            },
        }
    }
}

impl Eq for Elem {}

impl core::hash::Hash for Elem {
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {
        use discriminant_Elem::*;

        self.discriminant().hash(state);

        match self.discriminant() {
                        Button => {
                let payload_union = unsafe { self.ptr_read_union() };
                unsafe { payload_union.Button.hash(state) };
            },
            Col => {
                let payload_union = unsafe { self.ptr_read_union() };
                unsafe { payload_union.Col.hash(state) };
            },
            Row => {
                let payload_union = unsafe { self.ptr_read_union() };
                unsafe { payload_union.Row.hash(state) };
            },
            Text => {
                let payload_union = unsafe { self.ptr_read_union() };
                unsafe { payload_union.Text.hash(state) };
            },
        }
    }
}

impl PartialOrd for Elem {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        Some(<Self as Ord>::cmp(self, other))
    }
}

impl Ord for Elem {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        use discriminant_Elem::*;

        use std::cmp::Ordering::*;

        match self.discriminant().cmp(&other.discriminant()) {
            Less => Less,
            Greater => Greater,
            Equal => unsafe {
                match self.discriminant() {
                                Button => {
                let payload_union1 = unsafe { self.ptr_read_union() };
                let payload_union2 = unsafe { other.ptr_read_union() };

                unsafe {
                    payload_union1.Button.cmp(&payload_union2.Button)
                }
            },
            Col => {
                let payload_union1 = unsafe { self.ptr_read_union() };
                let payload_union2 = unsafe { other.ptr_read_union() };

                unsafe {
                    payload_union1.Col.cmp(&payload_union2.Col)
                }
            },
            Row => {
                let payload_union1 = unsafe { self.ptr_read_union() };
                let payload_union2 = unsafe { other.ptr_read_union() };

                unsafe {
                    payload_union1.Row.cmp(&payload_union2.Row)
                }
            },
            Text => {
                let payload_union1 = unsafe { self.ptr_read_union() };
                let payload_union2 = unsafe { other.ptr_read_union() };

                unsafe {
                    payload_union1.Text.cmp(&payload_union2.Text)
                }
            },
                }
            },
        }
    }
}


impl core::fmt::Debug for Elem {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        use discriminant_Elem::*;

        match self.discriminant() {
                        Button => {
                let payload_union = unsafe { self.ptr_read_union() };

                unsafe {
                    f.debug_tuple("Elem::Button").field(&payload_union.Button.f0).field(&payload_union.Button.f1).finish()
                }
            },
            Col => {
                let payload_union = unsafe { self.ptr_read_union() };

                unsafe {
                    f.debug_tuple("Elem::Col").field(&payload_union.Col.f0).finish()
                }
            },
            Row => {
                let payload_union = unsafe { self.ptr_read_union() };

                unsafe {
                    f.debug_tuple("Elem::Row").field(&payload_union.Row.f0).finish()
                }
            },
            Text => {
                let payload_union = unsafe { self.ptr_read_union() };

                unsafe {
                    f.debug_tuple("Elem::Text").field(&payload_union.Text.f0).finish()
                }
            },
        }
    }
}


#[repr(C)]
union union_Elem {    Button: core::mem::ManuallyDrop<Elem_Button>,
    Col: core::mem::ManuallyDrop<Elem_Col>,
    Row: core::mem::ManuallyDrop<Elem_Col>,
    Text: core::mem::ManuallyDrop<Elem_Text>,
    _sizer: [u8; 8],
}



pub fn renderForHost() -> Elem {
    extern "C" {
        fn roc__renderForHost_1_exposed_generic(_: *mut Elem);
    }

    let mut ret = core::mem::MaybeUninit::uninit();

    unsafe {
        roc__renderForHost_1_exposed_generic(ret.as_mut_ptr(), );

        ret.assume_init()
    }
}